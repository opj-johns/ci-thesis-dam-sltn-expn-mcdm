% Target sensitivity Analysis for all 4 models

% Weighted sensitivity analysis for WGP
% Resource sensitivity analysis for all.

%% === Generate 10 weight sets (Dirichlet(1): uniform on simplex) ===
numSets = 10; 
dim = 10;  % number of goals/weights

% Dirichlet(1) sampler: normalize i.i.d. Exp(1)
X = -log(rand(numSets, dim));
W_sets = X ./ sum(X,2);   % each row sums to 1

disp("Weight sets (rows sum to 1):");
disp(W_sets);

%% === Generate 10 RHS target sets (±20% via stratified/LHS sampling) ===
rhs_base = [47, 3, 0.04, 48.74, 0.52, 22.07, 1.86, 0.32, 0.23, 0.68];

% Latin-hypercube–like stratified samples in [0,1]
edges = linspace(0,1,numSets+1);
u = edges(1:end-1) + rand(1,numSets).*(1/numSets);
u = u(randperm(numSets));  % permute strata

RHS_sets = zeros(numSets, length(rhs_base));
for j = 1:length(rhs_base)
    % column-specific permutation by circular shift for coverage
    u_shift = circshift(u, j-1);
    deltas = 0.8 + 0.4*u_shift;           % scale to [0.8,1.2]
    RHS_sets(:,j) = rhs_base(j) .* deltas;
end

disp("RHS target sets (each row is one scenario):");
disp(RHS_sets);
        

%% === Generate 10 resource-variation sets: Budget and #sites (K) ===
numSets     = 10;
budget_base = 500;     % base budget
K_pool      = [2,3,4,5];  % plausible numbers of sites to select

% --- Budget sets via stratified (LHS-like) ±20% around base ---
edges = linspace(0,1,numSets+1);
u = edges(1:end-1) + rand(1,numSets).*(1/numSets);  % one sample per stratum
u = u(randperm(numSets));                            % permute strata
Budget_sets = (0.8 + 0.4*u).' * budget_base;        % column vector in [0.8B, 1.2B]

% --- K sets: cycle through {2,3,4,5} to ensure coverage; then permute ---
    K_sets = K_pool( mod(0:numSets-1, numel(K_pool)) + 1 ).';
    K_sets = K_sets(randperm(numSets));                  % optional shuffle
    
    disp("Budget sets (each row is one scenario):");
    disp(Budget_sets);
    disp("K (number of sites) sets (each row is one scenario):");
    disp(K_sets);

%% Tabling - 
% Assume sols is a cell array with 10 solution vectors
% sols{1}, sols{2}, ..., sols{10}

% Convert cell array to a matrix (each column is a solution)
solMatrix = cell2mat(sols);

% Transpose if needed (depending on orientation of your vectors)
if size(solMatrix,1) < size(solMatrix,2)
    solMatrix = solMatrix';
end

% Create variable names for the table
varNames = strcat("Sol_", string(1:numel(sols)));

% Convert to table
resultsTable = array2table(solMatrix, 'VariableNames', varNames);

% Display table
disp(resultsTable)

%% WGP - Weight Sensitivity Analysis% === Decision variables ===

% binary variable {0,1}
xb = optimvar("xb",28,"LowerBound",0,"UpperBound", 1, "Type","integer");
n  = optimvar("n",10,"LowerBound",0);
p  = optimvar("p",10,"LowerBound",0);

% === Problem definition ===
prob = optimproblem;

% Preallocate storage
sols     = cell(10,1);   % each sol may be a vector
fvals    = zeros(10,1);  % numeric scalar
exitflags = zeros(10,1); % numeric scalar
outputs  = cell(10,1);   % struct, so use cell array

for i = 1:10
    curr_set = W_sets(i, : );   % take the i-th row (all columns)

    % === Objective Function ===
    prob.Objective = curr_set(1)*(1/47)*n(1) + curr_set(2)*(1/3)*n(2) + curr_set(3)*(1/0.04)*p(3) + curr_set(4)*(1/48.74)*p(4) + curr_set(5)*(1/0.52)*n(5) + ...
                    curr_set(6)*(1/22.07)*n(6) + curr_set(7)*(1/0.35)*p(7) + curr_set(8)*(1/0.32)*p(8) + curr_set(9)*(1/23)*p(9) + curr_set(10)*(1/0.68)*n(10);    

    % === Constraints ===

    % Dam height
    prob.Constraints.cons1 = ...
        29.00*xb(1) + 33.00*xb(2) + 71.00*xb(3) + 50.00*xb(4) + 40.00*xb(5) + 46.00*xb(6) + ...
        18.00*xb(7) + 64.00*xb(8) + 100.00*xb(9) + 85.00*xb(10) + 20.00*xb(11) + 20.00*xb(12) + ...
        26.00*xb(13) + 17.00*xb(14) + 15.00*xb(15) + 15.00*xb(16) + 45.00*xb(17) + 29.00*xb(18) + ...
        57.00*xb(19) + 55.00*xb(20) + 40.00*xb(21) + 36.00*xb(22) + 17.00*xb(23) + 55.00*xb(24) + ...
        70.00*xb(25) + 94.00*xb(26) + 79.00*xb(27) + 26.00*xb(28) + n(1) - p(1) == 47;
    
    %    Dam capacity
    prob.Constraints.cons2 = ...
        2.00*xb(1) + 18.00*xb(2) + 96.00*xb(3) + 83.00*xb(4) + 9.50*xb(5) + 13.00*xb(6) + ...
        2.00*xb(7) + 725.00*xb(8) + 197.00*xb(9) + 369.00*xb(10) + 2.70*xb(11) + 1.00*xb(12) + ...
        1.30*xb(13) + 1.00*xb(14) + 1.10*xb(15) + 2.30*xb(16) + 43.00*xb(17) + 1.00*xb(18) + ...
        6.50*xb(19) + 62.00*xb(20) + 1.00*xb(21) + 12.00*xb(22) + 2.00*xb(23) + 55.50*xb(24) + ...
        592.00*xb(25) + 216.00*xb(26) + 110.00*xb(27) + 3.00*xb(28) + n(2) - p(2) == 3;
    
    % Reservoir area
    prob.Constraints.cons3 = ...
        0.08*xb(1) + 0.24*xb(2) + 0.60*xb(3) + 0.88*xb(4) + 0.26*xb(5) + 0.07*xb(6) + ...
        0.08*xb(7) + 20.00*xb(8) + 0.50*xb(9) + 1.90*xb(10) + 0.08*xb(11) + 0.29*xb(12) + ...
        0.02*xb(13) + 0.03*xb(14) + 0.03*xb(15) + 0.07*xb(16) + 0.33*xb(17) + 0.02*xb(18) + ...
        0.02*xb(19) + 0.43*xb(20) + 0.01*xb(21) + 0.31*xb(22) + 0.05*xb(23) + 0.34*xb(24) + ...
        4.76*xb(25) + 0.75*xb(26) + 0.51*xb(27) + 0.01*xb(28) + n(3) - p(3) == 0.04;
    
    % Temperature
    prob.Constraints.cons4 = ...
        18.94*xb(1) + 18.75*xb(2) + 19.06*xb(3) + 19.10*xb(4) + 18.94*xb(5) + 18.00*xb(6) + ...
        18.78*xb(7) + 18.98*xb(8) + 16.30*xb(9) + 17.50*xb(10) + 16.38*xb(11) + 21.37*xb(12) + ...
        18.98*xb(13) + 18.42*xb(14) + 18.00*xb(15) + 18.00*xb(16) + 18.00*xb(17) + 19.29*xb(18) + ...
        16.26*xb(19) + 16.92*xb(20) + 18.95*xb(21) + 14.70*xb(22) + 18.54*xb(23) + 16.92*xb(24) + ...
        16.67*xb(25) + 21.27*xb(26) + 17.40*xb(27) + 15.56*xb(28) + n(4) - p(4) == 48.74;
    
    % Population: normalized between 0 and 50.
    prob.Constraints.cons5 = ...
        0.24*xb(1) + 0.38*xb(2) + 0.24*xb(3) + 21.80*xb(4) + 0.28*xb(5) + ...
        0.23*xb(6) + 0.13*xb(7) + 0.14*xb(8) + 0.51*xb(9) + 0.57*xb(10) + ...
        0.00*xb(11) + 0.66*xb(12) + 0.20*xb(13) + 0.19*xb(14) + 50.00*xb(15) + ...
        50.00*xb(16) + 5.12*xb(17) + 0.40*xb(18) + 0.45*xb(19) + 1.27*xb(20) + ...
        0.31*xb(21) + 0.23*xb(22) + 0.83*xb(23) + 0.21*xb(24) + 1.53*xb(25) + ...
        0.19*xb(26) + 0.68*xb(27) + 0.37*xb(28) + n(5) - p(5) == 0.52;
    
    % Rainfall
    prob.Constraints.cons6 = ...
        15.98*xb(1) + 17.45*xb(2) + 10.80*xb(3) + 13.32*xb(4) + 15.98*xb(5) + 19.57*xb(6) + ...
        12.29*xb(7) + 17.02*xb(8) + 10.47*xb(9) + 12.15*xb(10) + 11.52*xb(11) + 3.73*xb(12) + ...
        17.19*xb(13) + 19.19*xb(14) + 19.57*xb(15) + 19.57*xb(16) + 19.57*xb(17) + 30.36*xb(18) + ...
        22.99*xb(19) + 33.23*xb(20) + 25.07*xb(21) + 25.41*xb(22) + 16.42*xb(23) + 33.23*xb(24) + ...
        7.88*xb(25) + 9.31*xb(26) + 8.07*xb(27) + 7.54*xb(28) + n(6) - p(6) == 22.07;
    
    % Residence
    prob.Constraints.cons7 = ...
        3.52*xb(1) + 11.65*xb(2) + 0.70*xb(3) + 3.58*xb(4) + 4.08*xb(5) + 2.97*xb(6) + 2.50*xb(7) +...
        15.76*xb(8) + 3.20*xb(9) + 7.82*xb(10) + 28.64*xb(11) + 0.81*xb(12) + 3.91*xb(13) + ...
        2.60*xb(14) + 9.72*xb(15) + 6.61*xb(16) + 3.58*xb(17) + 0.35*xb(18) + 0.81*xb(19) + ...
        3.63*xb(20) + 13.91*xb(21) + 9.59*xb(22) + 2.53*xb(23) + 2.95*xb(24) + 14.84*xb(25) + ...
        25.23*xb(26) + 3.86*xb(27) + 11.30*xb(28) + n(7) - p(7) == 1.86;
    
    % Farmland distance
    prob.Constraints.cons8 = ...
        0.10*xb(1) + 1.29*xb(2) + 0.11*xb(3) + 3.63*xb(4) + 1.69*xb(5) + 5.11*xb(6) + ...
        2.75*xb(7) + 2.90*xb(8) + 6.35*xb(9) + 0.16*xb(10) + 16.80*xb(11) + 0.90*xb(12) + ...
        0.33*xb(13) + 3.24*xb(14) + 0.11*xb(15) + 0.26*xb(16) + 0.35*xb(17) + 1.77*xb(18) + ...
        0.90*xb(19) + 2.47*xb(20) + 2.97*xb(21) + 8.20*xb(22) + 0.24*xb(23) + 5.47*xb(24) + ...
        8.13*xb(25) + 3.62*xb(26) + 0.58*xb(27) + 0.93*xb(28) + n(8) - p(8) == 0.32;
    
    % Nearest road
    prob.Constraints.cons9 = ...
        0.01*xb(1) + 0.21*xb(2) + 0.25*xb(3) + 0.01*xb(4) + 0.11*xb(5) + 1.12*xb(6) + ...
        0.23*xb(7) + 0.02*xb(8) + 0.01*xb(9) + 2.82*xb(10) + 5.69*xb(11) + 0.86*xb(12) + ...
        0.83*xb(13) + 0.28*xb(14) + 0.83*xb(15) + 0.21*xb(16) + 4.98*xb(17) + 3.49*xb(18) + ...
        0.93*xb(19) + 1.80*xb(20) + 5.15*xb(21) + 0.55*xb(22) + 1.46*xb(23) + 2.31*xb(24) + ...
        0.29*xb(25) + 0.22*xb(26) + 1.26*xb(27) + 3.30*xb(28) + n(9) - p(9) == 0.23;
    
    % Farmland area
    prob.Constraints.cons10 = ...
        226.95*xb(1) + 214.26*xb(2) + 6.02*xb(3) + 36.19*xb(4) + 60.24*xb(5) + 0.13*xb(6) + ...
        0.05*xb(7) + 23.57*xb(8) + 41.94*xb(9) + 21.81*xb(10) + 0.01*xb(11) + 12.05*xb(12) + ...
        16.21*xb(13) + 31.09*xb(14) + 36.08*xb(15) + 36.08*xb(16) + 12.80*xb(17) + 2.09*xb(18) + ...
        0.62*xb(19) + 15.55*xb(20) + 27.25*xb(21) + 8.79*xb(22) + 91.07*xb(23) + 0.01*xb(24) + ...
        21.96*xb(25) + 1.13*xb(26) + 33.78*xb(27) + 8.54*xb(28) + n(10) - p(10) == 0.68;
    
    
    % Selection (3 dams)
    prob.Constraints.cons11 = ...
        xb(1) + xb(2) + xb(3) + xb(4) + xb(5) + xb(6) + xb(7) + xb(8) + xb(9) + xb(10) + ...
        xb(11) + xb(12) + xb(13) + xb(14) + xb(15) + xb(16) + xb(17) + xb(18) + xb(19) + xb(20) + ...
        xb(21) + xb(22) + xb(23) + xb(24) + xb(25) + xb(26) + xb(27) + xb(28) == 3;
    
    % Budget: Estimated
    prob.Constraints.cons12 = ...
        163.4*xb(1)  + 170.9*xb(2)  + 158.2*xb(3)  + 180.9*xb(4)  + 168.6*xb(5)  + ...
        174.8*xb(6)  + 167.3*xb(7)  + 192.5*xb(8)  + 191.2*xb(9)  + 180.3*xb(10) + ...
        193.8*xb(11) + 152.2*xb(12) + 156.8*xb(13) + 166.0*xb(14) + 153.2*xb(15) + ...
        154.8*xb(16) + 169.2*xb(17) + 157.5*xb(18) + 158.7*xb(19) + 166.5*xb(20) + ...
        164.3*xb(21) + 177.4*xb(22) + 165.3*xb(23) + 169.5*xb(24) + 186.7*xb(25) + ...
        191.9*xb(26) + 190.4*xb(27) + 172.1*xb(28) <= 500;
    
   
    % === Convert to solver-based form ===
    problem = prob2struct(prob);
        
    % === Solve using intlinprog ===
    [sol,fval,exitflag,output] = intlinprog(problem);

    % store results
    sols{i}      = sol;
    fvals(i)     = fval;
    exitflags(i) = exitflag;
    outputs{i}   = output;
end

% After the loop, you can access them like:
disp(fvals)         % all objective values
disp(sols{3})       % solution vector from run 3
disp(exitflags(5))  % exitflag from run 5


%% WGP - Target Sensiivity Analysis
% === Decision variables ===

% binary variable {0,1}
xb = optimvar("xb",28,"LowerBound",0,"UpperBound", 1, "Type","integer");
n  = optimvar("n",10,"LowerBound",0);
p  = optimvar("p",10,"LowerBound",0);

% === Problem definition ===
prob = optimproblem;

% Preallocate storage
sols     = cell(10,1);   % each sol may be a vector
fvals    = zeros(10,1);  % numeric scalar
exitflags = zeros(10,1); % numeric scalar
outputs  = cell(10,1);   % struct, so use cell array

for i = 1:10
    curr_set = RHS_sets(i, : );   % take the i-th row (all columns)

    % === Objective Function ===
    prob.Objective = (1/47)*n(1) + (1/3)*n(2) + (1/0.04)*p(3) + (1/48.74)*p(4) + (1/0.52)*n(5) + ...
                    (1/22.07)*n(6) + (1/0.35)*p(7) + (1/0.32)*p(8) + (1/23)*p(9) + (1/0.68)*n(10);

    % === Constraints ===

    % Dam height
    prob.Constraints.cons1 = ...
        29.00*xb(1) + 33.00*xb(2) + 71.00*xb(3) + 50.00*xb(4) + 40.00*xb(5) + 46.00*xb(6) + ...
        18.00*xb(7) + 64.00*xb(8) + 100.00*xb(9) + 85.00*xb(10) + 20.00*xb(11) + 20.00*xb(12) + ...
        26.00*xb(13) + 17.00*xb(14) + 15.00*xb(15) + 15.00*xb(16) + 45.00*xb(17) + 29.00*xb(18) + ...
        57.00*xb(19) + 55.00*xb(20) + 40.00*xb(21) + 36.00*xb(22) + 17.00*xb(23) + 55.00*xb(24) + ...
        70.00*xb(25) + 94.00*xb(26) + 79.00*xb(27) + 26.00*xb(28) + n(1) - p(1) == curr_set(1);
    
    % Dam capacity
    prob.Constraints.cons2 = ...
        2.00*xb(1) + 18.00*xb(2) + 96.00*xb(3) + 83.00*xb(4) + 9.50*xb(5) + 13.00*xb(6) + ...
        2.00*xb(7) + 725.00*xb(8) + 197.00*xb(9) + 369.00*xb(10) + 2.70*xb(11) + 1.00*xb(12) + ...
        1.30*xb(13) + 1.00*xb(14) + 1.10*xb(15) + 2.30*xb(16) + 43.00*xb(17) + 1.00*xb(18) + ...
        6.50*xb(19) + 62.00*xb(20) + 1.00*xb(21) + 12.00*xb(22) + 2.00*xb(23) + 55.50*xb(24) + ...
        592.00*xb(25) + 216.00*xb(26) + 110.00*xb(27) + 3.00*xb(28) + n(2) - p(2) ==  curr_set(2);
    
    % Reservoir area
    prob.Constraints.cons3 = ...
        0.08*xb(1) + 0.24*xb(2) + 0.60*xb(3) + 0.88*xb(4) + 0.26*xb(5) + 0.07*xb(6) + ...
        0.08*xb(7) + 20.00*xb(8) + 0.50*xb(9) + 1.90*xb(10) + 0.08*xb(11) + 0.29*xb(12) + ...
        0.02*xb(13) + 0.03*xb(14) + 0.03*xb(15) + 0.07*xb(16) + 0.33*xb(17) + 0.02*xb(18) + ...
        0.02*xb(19) + 0.43*xb(20) + 0.01*xb(21) + 0.31*xb(22) + 0.05*xb(23) + 0.34*xb(24) + ...
        4.76*xb(25) + 0.75*xb(26) + 0.51*xb(27) + 0.01*xb(28) + n(3) - p(3) ==  curr_set(3);
    
    % Temperature
    prob.Constraints.cons4 = ...
        18.94*xb(1) + 18.75*xb(2) + 19.06*xb(3) + 19.10*xb(4) + 18.94*xb(5) + 18.00*xb(6) + ...
        18.78*xb(7) + 18.98*xb(8) + 16.30*xb(9) + 17.50*xb(10) + 16.38*xb(11) + 21.37*xb(12) + ...
        18.98*xb(13) + 18.42*xb(14) + 18.00*xb(15) + 18.00*xb(16) + 18.00*xb(17) + 19.29*xb(18) + ...
        16.26*xb(19) + 16.92*xb(20) + 18.95*xb(21) + 14.70*xb(22) + 18.54*xb(23) + 16.92*xb(24) + ...
        16.67*xb(25) + 21.27*xb(26) + 17.40*xb(27) + 15.56*xb(28) + n(4) - p(4) ==  curr_set(4);
    
    % Population: normalized between 0 and 50.
    prob.Constraints.cons5 = ...
        0.24*xb(1) + 0.38*xb(2) + 0.24*xb(3) + 21.80*xb(4) + 0.28*xb(5) + ...
        0.23*xb(6) + 0.13*xb(7) + 0.14*xb(8) + 0.51*xb(9) + 0.57*xb(10) + ...
        0.00*xb(11) + 0.66*xb(12) + 0.20*xb(13) + 0.19*xb(14) + 50.00*xb(15) + ...
        50.00*xb(16) + 5.12*xb(17) + 0.40*xb(18) + 0.45*xb(19) + 1.27*xb(20) + ...
        0.31*xb(21) + 0.23*xb(22) + 0.83*xb(23) + 0.21*xb(24) + 1.53*xb(25) + ...
        0.19*xb(26) + 0.68*xb(27) + 0.37*xb(28) + n(5) - p(5) ==  curr_set(5);
    
    % Rainfall
    prob.Constraints.cons6 = ...
        15.98*xb(1) + 17.45*xb(2) + 10.80*xb(3) + 13.32*xb(4) + 15.98*xb(5) + 19.57*xb(6) + ...
        12.29*xb(7) + 17.02*xb(8) + 10.47*xb(9) + 12.15*xb(10) + 11.52*xb(11) + 3.73*xb(12) + ...
        17.19*xb(13) + 19.19*xb(14) + 19.57*xb(15) + 19.57*xb(16) + 19.57*xb(17) + 30.36*xb(18) + ...
        22.99*xb(19) + 33.23*xb(20) + 25.07*xb(21) + 25.41*xb(22) + 16.42*xb(23) + 33.23*xb(24) + ...
        7.88*xb(25) + 9.31*xb(26) + 8.07*xb(27) + 7.54*xb(28) + n(6) - p(6) == curr_set(6);
    % Residence
    prob.Constraints.cons7 = ...
        3.52*xb(1) + 11.65*xb(2) + 0.70*xb(3) + 3.58*xb(4) + 4.08*xb(5) + 2.97*xb(6) + 2.50*xb(7) +...
        15.76*xb(8) + 3.20*xb(9) + 7.82*xb(10) + 28.64*xb(11) + 0.81*xb(12) + 3.91*xb(13) + ...
        2.60*xb(14) + 9.72*xb(15) + 6.61*xb(16) + 3.58*xb(17) + 0.35*xb(18) + 0.81*xb(19) + ...
        3.63*xb(20) + 13.91*xb(21) + 9.59*xb(22) + 2.53*xb(23) + 2.95*xb(24) + 14.84*xb(25) + ...
        25.23*xb(26) + 3.86*xb(27) + 11.30*xb(28) + n(7) - p(7) ==  curr_set(7);
    
    % Farmland distance
    prob.Constraints.cons8 = ...
        0.10*xb(1) + 1.29*xb(2) + 0.11*xb(3) + 3.63*xb(4) + 1.69*xb(5) + 5.11*xb(6) + ...
        2.75*xb(7) + 2.90*xb(8) + 6.35*xb(9) + 0.16*xb(10) + 16.80*xb(11) + 0.90*xb(12) + ...
        0.33*xb(13) + 3.24*xb(14) + 0.11*xb(15) + 0.26*xb(16) + 0.35*xb(17) + 1.77*xb(18) + ...
        0.90*xb(19) + 2.47*xb(20) + 2.97*xb(21) + 8.20*xb(22) + 0.24*xb(23) + 5.47*xb(24) + ...
        8.13*xb(25) + 3.62*xb(26) + 0.58*xb(27) + 0.93*xb(28) + n(8) - p(8) ==  curr_set(8);
    
    % Nearest road
    prob.Constraints.cons9 = ...
        0.01*xb(1) + 0.21*xb(2) + 0.25*xb(3) + 0.01*xb(4) + 0.11*xb(5) + 1.12*xb(6) + ...
        0.23*xb(7) + 0.02*xb(8) + 0.01*xb(9) + 2.82*xb(10) + 5.69*xb(11) + 0.86*xb(12) + ...
        0.83*xb(13) + 0.28*xb(14) + 0.83*xb(15) + 0.21*xb(16) + 4.98*xb(17) + 3.49*xb(18) + ...
        0.93*xb(19) + 1.80*xb(20) + 5.15*xb(21) + 0.55*xb(22) + 1.46*xb(23) + 2.31*xb(24) + ...
        0.29*xb(25) + 0.22*xb(26) + 1.26*xb(27) + 3.30*xb(28) + n(9) - p(9) ==  curr_set(9);
    
    % Farmland area
    prob.Constraints.cons10 = ...
        226.95*xb(1) + 214.26*xb(2) + 6.02*xb(3) + 36.19*xb(4) + 60.24*xb(5) + 0.13*xb(6) + ...
        0.05*xb(7) + 23.57*xb(8) + 41.94*xb(9) + 21.81*xb(10) + 0.01*xb(11) + 12.05*xb(12) + ...
        16.21*xb(13) + 31.09*xb(14) + 36.08*xb(15) + 36.08*xb(16) + 12.80*xb(17) + 2.09*xb(18) + ...
        0.62*xb(19) + 15.55*xb(20) + 27.25*xb(21) + 8.79*xb(22) + 91.07*xb(23) + 0.01*xb(24) + ...
        21.96*xb(25) + 1.13*xb(26) + 33.78*xb(27) + 8.54*xb(28) + n(10) - p(10) ==  curr_set(10);
    
    
    % Selection (3 dams)
    prob.Constraints.cons11 = ...
        xb(1) + xb(2) + xb(3) + xb(4) + xb(5) + xb(6) + xb(7) + xb(8) + xb(9) + xb(10) + ...
        xb(11) + xb(12) + xb(13) + xb(14) + xb(15) + xb(16) + xb(17) + xb(18) + xb(19) + xb(20) + ...
        xb(21) + xb(22) + xb(23) + xb(24) + xb(25) + xb(26) + xb(27) + xb(28) == 3;
    
    % Budget: Estimated
    prob.Constraints.cons12 = ...
        163.4*xb(1)  + 170.9*xb(2)  + 158.2*xb(3)  + 180.9*xb(4)  + 168.6*xb(5)  + ...
        174.8*xb(6)  + 167.3*xb(7)  + 192.5*xb(8)  + 191.2*xb(9)  + 180.3*xb(10) + ...
        193.8*xb(11) + 152.2*xb(12) + 156.8*xb(13) + 166.0*xb(14) + 153.2*xb(15) + ...
        154.8*xb(16) + 169.2*xb(17) + 157.5*xb(18) + 158.7*xb(19) + 166.5*xb(20) + ...
        164.3*xb(21) + 177.4*xb(22) + 165.3*xb(23) + 169.5*xb(24) + 186.7*xb(25) + ...
        191.9*xb(26) + 190.4*xb(27) + 172.1*xb(28) <= 500;
    
    
    % === Convert to solver-based form ===
    problem = prob2struct(prob);
    
    %options = optimoptions('intlinprog','Display','none');
    
    % === Solve using intlinprog ===
    [sol,fval,exitflag,output] = intlinprog(problem);

    % store results
    sols{i}      = sol;
    fvals(i)     = fval;
    exitflags(i) = exitflag;
    outputs{i}   = output;
end

% After the loop, you can access them like:
disp(fvals)         % all objective values
disp(sols{3})       % solution vector from run 3
disp(exitflags(5))  % exitflag from run 5
